#include <util/crc16.h>
#include "Arduino.h"
#include "Wire.h"

void setup() {
  Wire.begin();
}

#define page_size %d
#define frame_size %d
#define blank 0x%x
#define pages %d
#define firmware_length %d
#define DELAY %d
#define ADDRESS 0x58


#define ENDTRANS_SUCCESS 0
#define ENDTRANS_DATA_TOO_LONG 1
#define ENDTRANS_ADDR_NACK 2
#define ENDTRANS_DATA_NACK 3
#define ENDTRANS_ERROR

uint16_t offsets[pages] = {%s};
const byte firmware[firmware_length] PROGMEM = {%s};

byte written = 0;


void reset_attiny() {
    // Hold the left ATTiny in reset, 
    DDRC |= _BV(6);
    PORTC &= ~_BV(6);
    delay(30);
    DDRC &= ~_BV(6); // Turn the ATTiny back on
}

void print_result(byte result) {
    Serial.print("result = ");
    Serial.print(result);
    Serial.print("\n");

}

byte run_command(byte address, byte command) {

    Wire.beginTransmission(address);
    Wire.write(command); // erase user space
    Wire.write(0x00); // dummy end byte
    byte result = Wire.endTransmission();
    print_result(result);
    return result;
}

void loop() {
  byte addr = ADDRESS;

  reset_attiny();

  if (written != 0) {
    // we're done
    return;
  }

  Serial.print("Communicating\n");

  byte result = ENDTRANS_ADDR_NACK;
  while (result != ENDTRANS_DATA_NACK) {
    Serial.print("Erasing\n");
    result = run_command(addr, 0x04); // erase

    _delay_ms(100);
  }

  byte o = 0;

  for (uint16_t i = 0; i < firmware_length; i += page_size) {
    Serial.print("Setting addr\n");
    Wire.beginTransmission(addr);
    Wire.write(0x1); // write page addr
    Wire.write(offsets[o] & 0xff); // write page addr
    Wire.write(offsets[o] >> 8);
    Wire.write(0x00); // dummy end byte
    result = Wire.endTransmission();
    print_result(result);
    _delay_ms(DELAY);
    // got something other than NACK. Start over.
    if (result != ENDTRANS_DATA_NACK) {
      return;
    }

    // transmit each frame separately
    for (uint8_t frame = 0; frame < page_size / frame_size; frame++) {
      Wire.beginTransmission(addr);
      Wire.write(0x2); // continue page
      uint16_t crc16 = 0xffff;
      for (uint8_t j = frame * frame_size; j < (frame + 1) * frame_size; j++) {
        if (i + j < firmware_length) {
          Wire.write(pgm_read_byte_near(firmware+i + j));
          crc16 = _crc16_update(crc16, pgm_read_byte_near(firmware+i + j));
        } else {
          Wire.write(blank);
          crc16 = _crc16_update(crc16, blank);
        }
      }
      // write the CRC16, little end first
      Wire.write(crc16 & 0xff);
      Wire.write(crc16 >> 8);
      Wire.write(0x00); // dummy end byte
      result = Wire.endTransmission();
      Serial.print("got ");
      Serial.print(result);
      Serial.print(" for page ");
      Serial.print(offsets[o]);
      Serial.print(" frame ");
      Serial.print(frame);
      Serial.print("\n");

      // got something other than NACK. Start over.
      if (result != ENDTRANS_DATA_NACK) {
        return;
      }
      delay(DELAY);
    }
    o++;
  }
  written = 1; // firmware successfully rewritten

  Serial.print("resetting\n");
  result = run_command(addr, 0x03); // execute app
  Serial.print("done\n");
}
