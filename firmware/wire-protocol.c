#include "wire-protocol.h"
#include <string.h>
#include "main.h"
#include "twi-slave.h"
#include "i2c_addr.h"


uint8_t led_spi_frequency = LED_SPI_FREQUENCY_DEFAULT;

void twi_init(void) {

    TWI_Rx_Data_Callback = twi_data_received;
    TWI_Tx_Data_Callback = twi_data_requested;

    TWI_Slave_Initialise(I2C_ADDRESS); // generated by gen_map.py
    sei();
    DDRC |= _BV(1); // PC1 is pin 24
}

static uint8_t twi_command = TWI_CMD_NONE;

void twi_data_received(uint8_t *buf, uint8_t bufsiz) {
    // if the upper four bits of the byte say this is an LED cmd
    // this is the most common case. It's also the only case where
    // we can't just compare buf[0] to a static value
    if (__builtin_expect( ((buf[0] & 0xf0) == TWI_CMD_LED_BASE),1))  {
        //led_update_bank(&buf[1], buf[0] & 0x0f); // the lowest four bits are the bank #
        return;
    }

    switch (buf[0]) {
    case TWI_CMD_KEYSCAN_INTERVAL:
        if (bufsiz == 2 ) {
            // SET the delay
            OCR1A = buf[1];
        } else {
            // GET configuration
            twi_command = TWI_CMD_KEYSCAN_INTERVAL;
        }
        break;
/*
    case TWI_CMD_LED_SPI_FREQUENCY:
        if (bufsiz == 2 ) {
            led_spi_frequency = buf[1];
            led_set_spi_frequency(led_spi_frequency);
        } else {
            twi_command = TWI_CMD_LED_SPI_FREQUENCY;
        }
        break;
    */

    case TWI_CMD_LED_SET_ALL_TO:
        if (bufsiz == 4 ) {
            //led_set_all_to(&buf[1]);
            sig_pin(buf[1]);
        }
        break;

    case TWI_CMD_LED_SET_ONE_TO:
        if (bufsiz == 5 ) {
            //led_set_one_to(buf[1],&buf[2]);
        }
        break;

    case TWI_CMD_JOINED:
        twi_command = TWI_CMD_JOINED;
        break;

    case TWI_CMD_VERSION:
        twi_command = TWI_CMD_VERSION;
        //sig_pin(true); // set it, which pulls pin low
        break;

    case TWI_CMD_SLED_STATUS:
        twi_command = TWI_CMD_SLED_STATUS;
        break;

    case TWI_CMD_LED_OPEN:
        twi_command = TWI_CMD_LED_OPEN;
        break;

    case TWI_CMD_LED_SHORT:
        twi_command = TWI_CMD_LED_SHORT;
        break;

        /*
    case TWI_CMD_LED_GLOBAL_BRIGHTNESS:
	led_set_global_brightness(buf[1]);
	break;
    */
    }
}

uint8_t key_substate;
bool state = true;

void twi_data_requested(uint8_t *buf, uint8_t *bufsiz) {
    if (__builtin_expect(*bufsiz != 0, 1)) {
        switch (twi_command) {
        case TWI_CMD_NONE:
            // Keyscanner Status Register
            buf[0]=TWI_REPLY_KEYDATA;
            buf[1]=get_pin();
            buf[2]=0;
            buf[3]=0;
            buf[4]=0;
            buf[5]=0;
            *bufsiz=6;
            break;
        case TWI_CMD_VERSION:
            buf[0] = DEVICE_VERSION;
            *bufsiz = 1;
            twi_command = TWI_CMD_NONE;
            break;
        case TWI_CMD_KEYSCAN_INTERVAL:
            buf[0] = OCR1A;
            *bufsiz = 1;
            twi_command = TWI_CMD_NONE;
            break;
        case TWI_CMD_LED_SPI_FREQUENCY:
            buf[0] = led_spi_frequency;
            *bufsiz = 1;
            twi_command = TWI_CMD_NONE;
            break;
        case TWI_CMD_SLED_STATUS:
            buf[0] = 0;
            *bufsiz = 1;
            twi_command = TWI_CMD_NONE;
            break;
        case TWI_CMD_LED_OPEN:
            //memcpy(buf, led_open_status, 32);
            *bufsiz = 32;
            twi_command = TWI_CMD_NONE;
            break;
        case TWI_CMD_LED_SHORT:
            //memcpy(buf, led_short_status, 32);
            *bufsiz = 32;
            twi_command = TWI_CMD_NONE;
            break;
        case TWI_CMD_JOINED:
            buf[0] = JOINT();
            *bufsiz = 1;
            twi_command = TWI_CMD_NONE;
            break;
        default:
            buf[0] = 0x01;
            *bufsiz = 1;
            break;
        }
    }
}
